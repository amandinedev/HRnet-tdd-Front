import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import EmployeeForm from '../components/EmployeeForm/EmployeeForm';
import employeeReducer from '../reduxFeatures/employeeSlice';

// Helper function to create store
const createTestStore = (preloadedState = {}) => {
  return configureStore({
    reducer: {
      employees: employeeReducer,
    },
    preloadedState,
  });
};

// Helper function to render component with store
const renderWithStore = (store) => {
  return render(
    <Provider store={store}>
      <EmployeeForm />
    </Provider>
  );
};

// Helper to get test IDs based on label (matches your component's toCamelCase)
const toCamelCase = (str) => {
  return str
    .split(' ')
    .map((word, index) => 
      index === 0 
        ? word.toLowerCase() 
        : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    )
    .join('');
};

// Helper to select from dropdown
const selectFromDropdown = async (label, optionText) => {
  const camelCaseLabel = toCamelCase(label);
  const triggerTestId = `input-select-trigger-${camelCaseLabel}`;
  
  // Click dropdown trigger
  const trigger = screen.getByTestId(triggerTestId);
  fireEvent.click(trigger);
  
  // Wait for options
  await waitFor(() => {
    expect(screen.getByTestId(`input-select-options-${camelCaseLabel}`)).toBeInTheDocument();
  });
  
  // Find and click option
  const optionsContainer = screen.getByTestId(`input-select-options-${camelCaseLabel}`);
  const options = optionsContainer.querySelectorAll('button[role="option"]');
  
  // Find option by text (skip placeholder at index 0)
  for (let i = 1; i < options.length; i++) {
    if (options[i].textContent.includes(optionText)) {
      fireEvent.click(options[i]);
      return;
    }
  }
  
  // If not found by text, click first non-placeholder option
  if (options[1]) {
    fireEvent.click(options[1]);
  }
};

// Helper to fill date input
const fillDateInput = (label, dateString) => {
  const camelCaseLabel = toCamelCase(label);
  const dateInput = screen.getByTestId(`input-${camelCaseLabel}`);
  
  // React DatePicker wraps the input
  const inputElement = dateInput.querySelector('input') || dateInput;
  fireEvent.change(inputElement, { 
    target: { value: dateString } 
  });
  fireEvent.blur(inputElement);
};

// Helper to fill entire form
const fillFormWithData = async () => {
  // Fill text inputs
  fireEvent.change(screen.getByTestId('input-firstName'), { 
    target: { value: 'John' } 
  });
  
  fireEvent.change(screen.getByTestId('input-lastName'), { 
    target: { value: 'Doe' } 
  });
  
  fireEvent.change(screen.getByTestId('input-street'), { 
    target: { value: '123 Main Street' } 
  });
  
  fireEvent.change(screen.getByTestId('input-city'), { 
    target: { value: 'New York' } 
  });
  
  fireEvent.change(screen.getByTestId('input-zipCode'), { 
    target: { value: '10001' } 
  });
  
  // Fill date inputs
  fillDateInput('Date of Birth', '01/01/1980');
  fillDateInput('Start Date', '06/01/2023');
  
  // Select from dropdowns
  await selectFromDropdown('State', 'New York');
  await selectFromDropdown('Department', 'Engineering');
};

describe('EmployeeForm', () => {
  let store;
  let mockDispatch;

  beforeEach(() => {
    store = createTestStore({
      employees: {
        list: [],
        status: 'idle',
        error: null,
      },
    });
    
    mockDispatch = vi.fn();
    store.dispatch = mockDispatch;
  });

  // Debug test
  it('should show all available test IDs', () => {
    renderWithStore(store);
    
    const elements = document.querySelectorAll('[data-testid]');
    console.log('Found test IDs:');
    elements.forEach((el, i) => {
      console.log(`${i + 1}. ${el.getAttribute('data-testid')}`);
    });
  });

  describe('Form Rendering', () => {
    it('renders all form fields with correct test IDs', () => {
      renderWithStore(store);

      // Check all expected test IDs exist based on component generation
      expect(screen.getByTestId('input-firstName')).toBeInTheDocument();
      expect(screen.getByTestId('input-lastName')).toBeInTheDocument();
      expect(screen.getByTestId('input-dateOfBirth')).toBeInTheDocument();
      expect(screen.getByTestId('input-startDate')).toBeInTheDocument();
      expect(screen.getByTestId('input-street')).toBeInTheDocument();
      expect(screen.getByTestId('input-city')).toBeInTheDocument();
      expect(screen.getByTestId('input-zipCode')).toBeInTheDocument();
      
      // Dropdown triggers (generated by InputSelect)
      expect(screen.getByTestId('input-select-trigger-state')).toBeInTheDocument();
      expect(screen.getByTestId('input-select-trigger-department')).toBeInTheDocument();
      
      // Submit button (auto-generated from Button component)
      expect(screen.getByTestId('button-save')).toBeInTheDocument();
      
      // Address fieldset
      expect(screen.getByText('Address')).toBeInTheDocument();
    });
  });

  describe('Form Validation', () => {
    it('shows error messages for empty required fields', async () => {
      renderWithStore(store);

      // Submit empty form
      fireEvent.click(screen.getByTestId('button-save'));

      await waitFor(() => {
        // Check for multiple error messages
        const errors = screen.getAllByText(/Please fill in this field|Zip code is required|Please select a date|Please select an option/i);
        expect(errors.length).toBeGreaterThan(0);
      });
    });

    it('shows error for invalid first name with numbers', async () => {
      renderWithStore(store);

      fireEvent.change(screen.getByTestId('input-firstName'), { 
        target: { value: 'John123' } 
      });

      fireEvent.click(screen.getByTestId('button-save'));

      await waitFor(() => {
        expect(screen.getByText(/Only letters, hyphens, apostrophes, and spaces are allowed/i)).toBeInTheDocument();
      });
    });

    it('shows error for invalid zip code format', async () => {
      renderWithStore(store);

      fireEvent.change(screen.getByTestId('input-zipCode'), { 
        target: { value: '1234' } 
      });

      fireEvent.click(screen.getByTestId('button-save'));

      await waitFor(() => {
        expect(screen.getByText(/Please enter a valid zip code/i)).toBeInTheDocument();
      });
    });
  });

  describe('Form Submission', () => {
    it('displays modal on successful submission', async () => {
      renderWithStore(store);
      
      await fillFormWithData();
      
      // Submit form
      fireEvent.click(screen.getByTestId('button-save'));
      
      // Wait for modal - check for modal by text (since Modal might not have test ID)
      await waitFor(() => {
        expect(screen.getByText(/Employee has been successfully added/i)).toBeInTheDocument();
      }, { timeout: 3000 });
    });

    it('clears form after successful submission', async () => {
      renderWithStore(store);

      await fillFormWithData();
      
      // Verify form is filled
      expect(screen.getByTestId('input-firstName').value).toBe('John');
      expect(screen.getByTestId('input-lastName').value).toBe('Doe');
      expect(screen.getByTestId('input-zipCode').value).toBe('10001');
      
      // Submit
      fireEvent.click(screen.getByTestId('button-save'));
      
      // Wait for form to clear
      await waitFor(() => {
        expect(screen.getByTestId('input-firstName').value).toBe('');
        expect(screen.getByTestId('input-lastName').value).toBe('');
        expect(screen.getByTestId('input-zipCode').value).toBe('');
      }, { timeout: 3000 });
    });

    it('dispatches correct Redux actions on successful submission', async () => {
      renderWithStore(store);

      await fillFormWithData();
      
      fireEvent.click(screen.getByTestId('button-save'));

      await waitFor(() => {
        // Check that actions were dispatched
        expect(mockDispatch).toHaveBeenCalledWith({ 
          type: 'employees/addEmployeeStart' 
        });
        
        expect(mockDispatch).toHaveBeenCalledWith(
          expect.objectContaining({
            type: 'employees/addEmployeeSuccess',
            payload: expect.objectContaining({
              firstName: 'John',
              lastName: 'Doe',
              zipCode: '10001'
            })
          })
        );
      }, { timeout: 3000 });
    });
  });

  describe('Field Interactions', () => {
    it('clears specific field error when user starts typing in that field', async () => {
    renderWithStore(store);

    // Get the firstName input
    const firstNameInput = screen.getByTestId('input-firstName');
    
    // Submit empty form
    fireEvent.click(screen.getByTestId('button-save'));
    
    // Wait for firstName to have an error
    await waitFor(() => {
      // Check if error element exists for firstName
      const firstNameError = screen.queryByTestId('error-firstName');
      const allErrors = screen.queryAllByText(/Please fill in this field/i);
      
      // Either we have a specific error test ID or generic errors
      expect(firstNameError || allErrors.length > 0).toBeTruthy();
    });
    
    // Type in firstName
    fireEvent.change(firstNameInput, { target: { value: 'John' } });
    
    // Wait for firstName error to clear
    await waitFor(() => {
      const firstNameError = screen.queryByTestId('error-firstName');
      expect(firstNameError).not.toBeInTheDocument();
    }, { timeout: 2000 });
  });


    it('allows selecting from dropdowns', async () => {
      renderWithStore(store);
      
      // Open State dropdown
      fireEvent.click(screen.getByTestId('input-select-trigger-state'));
      
      await waitFor(() => {
        expect(screen.getByTestId('input-select-options-state')).toBeInTheDocument();
      });
      
      // Check options exist
      const options = screen.getByTestId('input-select-options-state');
      expect(options.querySelectorAll('button[role="option"]').length).toBeGreaterThan(1);
      
      // Select first non-placeholder option
      const firstOption = options.querySelectorAll('button[role="option"]')[1];
      fireEvent.click(firstOption);
    });
  });

});